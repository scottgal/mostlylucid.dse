name: "HTTP Server"
type: "custom"
version: "1.0.1"  # Version bump for optimization
description: "HTTP server that allows workflows to serve content via HTTP. Supports both HTML and JSON/API responses. Enable workflows to be exposed as web services or REST APIs. Can register endpoints, handle requests, and return formatted responses."

# Performance metadata
cost_tier: "free"
speed_tier: "very-fast"
quality_tier: "excellent"
max_output_length: "long"
priority: 90

# Custom implementation
custom:
  module: "src.http_server_tool"
  class: "HTTPServerTool"
  config:
    host: "${HTTP_SERVER_HOST:-0.0.0.0}"  # Environment variable support (NEW)
    port: "${HTTP_SERVER_PORT:-8080}"
    enable_cors: "${HTTP_SERVER_CORS:-true}"
    max_connections: "${HTTP_SERVER_MAX_CONN:-100}"
    timeout_seconds: "${HTTP_SERVER_TIMEOUT:-30}"

# Resource constraints (NEW)
constraints:
  timeout_ms: 60000
  max_memory_mb: 256
  max_cpu_percent: 50
  max_concurrent: 10

# Structured input schema (IMPROVED)
input_schema:
  type: object
  properties:
    action:
      type: string
      description: "Action to perform"
      enum: ["start", "stop", "add_route", "remove_route", "list_routes", "info"]
      required: true
    route_config:
      type: object
      description: "For 'add_route': route configuration"
      properties:
        path:
          type: string
          description: "URL path (e.g., '/api/hello')"
        methods:
          type: array
          items:
            type: string
            enum: ["GET", "POST", "PUT", "DELETE", "PATCH"]
          default: ["GET"]
        response_type:
          type: string
          enum: ["json", "html", "text"]
          default: "json"
        handler:
          type: string
          description: "Handler function name or callable"
      required: ["path"]
    blocking:
      type: boolean
      description: "For 'start': whether to block until server stops"
      default: false

# Structured output schema (IMPROVED)
output_schema:
  type: object
  properties:
    status:
      type: string
      enum: ["success", "error"]
      description: "Operation status"
    message:
      type: string
      description: "Status message"
    data:
      type: object
      description: "Additional data (routes, server info, etc.)"
      properties:
        url:
          type: string
          description: "Server URL"
        routes:
          type: array
          description: "Registered routes"
        is_running:
          type: boolean
          description: "Server running status"

tags: ["http", "server", "api", "web", "rest", "endpoint", "service", "html", "json", "networking"]

# Examples (EXPANDED)
examples:
  - input:
      action: "start"
      blocking: false
    output:
      status: "success"
      message: "Server started"
      data:
        url: "http://0.0.0.0:8080"
        is_running: true

  - input:
      action: "add_route"
      route_config:
        path: "/api/hello"
        methods: ["GET"]
        response_type: "json"
    output:
      status: "success"
      message: "Route added"
      data:
        path: "/api/hello"
        methods: ["GET"]

  - input:
      action: "list_routes"
    output:
      status: "success"
      data:
        routes:
          - path: "/api/hello"
            methods: ["GET"]
            type: "json"

  - input:
      action: "info"
    output:
      status: "success"
      data:
        host: "0.0.0.0"
        port: 8080
        is_running: true
        routes_count: 3

  - input:
      action: "stop"
    output:
      status: "success"
      message: "Server stopped"

# Usage documentation (ENHANCED)
usage_notes: |
  ## Overview
  HTTP server for exposing workflows as web services. Supports REST APIs,
  webhooks, and HTML pages.

  ## Actions

  ### start
  Start the HTTP server (non-blocking by default).
  - Input: `{"action": "start", "blocking": false}`
  - Returns: Server URL and status

  ### stop
  Stop the HTTP server.
  - Input: `{"action": "stop"}`
  - Returns: Confirmation message

  ### add_route
  Register a new HTTP endpoint.
  - Input: `{"action": "add_route", "route_config": {...}}`
  - Requires: path, optional methods/response_type
  - Returns: Route configuration

  ### remove_route
  Remove an HTTP endpoint.
  - Input: `{"action": "remove_route", "route_config": {"path": "/api/endpoint"}}`
  - Returns: Confirmation message

  ### list_routes
  Get all registered routes.
  - Input: `{"action": "list_routes"}`
  - Returns: Array of route configurations

  ### info
  Get server information.
  - Input: `{"action": "info"}`
  - Returns: Server status and configuration

  ## Response Types
  - **json**: Automatic JSON serialization
  - **html**: HTML page rendering
  - **text**: Plain text response

  ## Configuration
  Environment variables for customization:
  - `HTTP_SERVER_HOST`: Bind address (default: 0.0.0.0)
  - `HTTP_SERVER_PORT`: Port number (default: 8080)
  - `HTTP_SERVER_CORS`: Enable CORS (default: true)
  - `HTTP_SERVER_MAX_CONN`: Max connections (default: 100)
  - `HTTP_SERVER_TIMEOUT`: Request timeout (default: 30s)

  ## Use Cases
  - **REST API**: Expose workflow results as API endpoints
  - **Webhooks**: Receive HTTP callbacks from external services
  - **Web UI**: Serve HTML pages for workflow interactions
  - **Integration**: Connect workflows to external systems
  - **Monitoring**: Health check and status endpoints

  ## Security Considerations
  - Default binding to 0.0.0.0 (all interfaces) - change for production
  - No authentication by default - implement in handlers
  - CORS enabled by default - configure for production
  - Use reverse proxy (nginx) for production deployments
  - Implement rate limiting in handlers if needed

  ## Performance
  - Handles 100+ concurrent connections
  - Non-blocking by default
  - Minimal memory footprint
  - Suitable for development and light production use

  ## Best Practices
  1. Use environment variables for configuration
  2. Implement authentication in route handlers
  3. Add error handling to custom handlers
  4. Use appropriate response types
  5. Test routes before deployment
  6. Monitor server health and performance

  ## Integration Examples

  ### Simple API Endpoint
  ```python
  # Add a simple JSON API endpoint
  call_tool("http_server", {
      "action": "add_route",
      "route_config": {
          "path": "/api/status",
          "methods": ["GET"],
          "response_type": "json"
      }
  })
  ```

  ### HTML Page
  ```python
  # Serve an HTML page
  call_tool("http_server", {
      "action": "add_route",
      "route_config": {
          "path": "/",
          "methods": ["GET"],
          "response_type": "html"
      }
  })
  ```
