"""
Mock fixtures for ruff_checker tests.

This file is auto-generated by mock_generator.py.
Contains pytest fixtures for testing ruff_checker.
"""

import pytest
import tempfile
import subprocess
from pathlib import Path
from typing import Dict, Any
from unittest.mock import MagicMock, Mock


# ===== Shared Fixtures =====

@pytest.fixture
def temp_python_file():
    """Create a temporary Python file for testing."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write('print("Hello, World!")\n')
        temp_path = Path(f.name)
    yield temp_path
    if temp_path.exists():
        temp_path.unlink()


@pytest.fixture
def temp_dir():
    """Create a temporary directory for testing."""
    import tempfile
    temp_dir_path = Path(tempfile.mkdtemp())
    yield temp_dir_path
    import shutil
    shutil.rmtree(temp_dir_path, ignore_errors=True)


@pytest.fixture
def mock_subprocess_success(mocker):
    """Mock subprocess.run to return success (exit code 0)."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 0
    mock.return_value.stdout = ''
    mock.return_value.stderr = ''
    return mock


@pytest.fixture
def mock_subprocess_failure(mocker):
    """Mock subprocess.run to return failure (exit code 1)."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 1
    mock.return_value.stdout = 'Error: issues found'
    mock.return_value.stderr = ''
    return mock


@pytest.fixture
def mock_subprocess_error(mocker):
    """Mock subprocess.run to return error (exit code 2)."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 2
    mock.return_value.stdout = ''
    mock.return_value.stderr = 'Error: tool not found'
    return mock


@pytest.fixture
def mock_file_not_found(mocker):
    """Mock subprocess.run to raise FileNotFoundError."""
    mock = mocker.patch('subprocess.run')
    mock.side_effect = FileNotFoundError('Tool not found')
    return mock


@pytest.fixture
def mock_timeout(mocker):
    """Mock subprocess.run to raise TimeoutExpired."""
    mock = mocker.patch('subprocess.run')
    mock.side_effect = subprocess.TimeoutExpired('command', 30)
    return mock


# ===== Scenario-Specific Fixtures =====

@pytest.fixture
def clean_file():
    """Python file with no linting issues"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write("""#!/usr/bin/env python3
"""Clean Python file."""

def main():
    """Main function."""
    print("Hello, World!")

if __name__ == '__main__':
    main()
""")
        temp_path = Path(f.name)
    yield temp_path
    if temp_path.exists():
        temp_path.unlink()


@pytest.fixture
def file_with_unused_imports():
    """Python file with unused imports"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write("""import sys
import os  # unused
import json  # unused

def main():
    print(sys.version)

if __name__ == '__main__':
    main()
""")
        temp_path = Path(f.name)
    yield temp_path
    if temp_path.exists():
        temp_path.unlink()


@pytest.fixture
def file_with_syntax_error():
    """Python file with syntax errors"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write("""def main(
    print("Missing closing paren")
""")
        temp_path = Path(f.name)
    yield temp_path
    if temp_path.exists():
        temp_path.unlink()


# ===== Subprocess Mocks for Scenarios =====

@pytest.fixture
def mock_clean_file_subprocess(mocker):
    """Mock subprocess for clean_file scenario."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 0
    mock.return_value.stdout = """"""
    mock.return_value.stderr = """"""
    return mock


@pytest.fixture
def mock_file_with_unused_imports_subprocess(mocker):
    """Mock subprocess for file_with_unused_imports scenario."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 1
    mock.return_value.stdout = """[{"code": "F401", "message": "'os' imported but unused"}]"""
    mock.return_value.stderr = """"""
    return mock


@pytest.fixture
def mock_file_with_syntax_error_subprocess(mocker):
    """Mock subprocess for file_with_syntax_error scenario."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 1
    mock.return_value.stdout = """SyntaxError: invalid syntax"""
    mock.return_value.stderr = """"""
    return mock


# ===== Mock Data Constants =====

MOCK_TOOL_VERSION = "1.0.0"

MOCK_JSON_OUTPUT_TEMPLATE = {
    "success": True,
    "issues_found": 0,
    "output": "No issues found"
}

MOCK_ERROR_OUTPUT = {
    "success": False,
    "issues_found": 0,
    "output": "Error occurred"
}
