"""
Mock fixtures for bandit_checker tests.

This file is auto-generated by mock_generator.py.
Contains pytest fixtures for testing bandit_checker.
"""

import pytest
import tempfile
import subprocess
from pathlib import Path
from typing import Dict, Any
from unittest.mock import MagicMock, Mock


# ===== Shared Fixtures =====

@pytest.fixture
def temp_python_file():
    """Create a temporary Python file for testing."""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write('print("Hello, World!")\n')
        temp_path = Path(f.name)
    yield temp_path
    if temp_path.exists():
        temp_path.unlink()


@pytest.fixture
def temp_dir():
    """Create a temporary directory for testing."""
    import tempfile
    temp_dir_path = Path(tempfile.mkdtemp())
    yield temp_dir_path
    import shutil
    shutil.rmtree(temp_dir_path, ignore_errors=True)


@pytest.fixture
def mock_subprocess_success(mocker):
    """Mock subprocess.run to return success (exit code 0)."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 0
    mock.return_value.stdout = ''
    mock.return_value.stderr = ''
    return mock


@pytest.fixture
def mock_subprocess_failure(mocker):
    """Mock subprocess.run to return failure (exit code 1)."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 1
    mock.return_value.stdout = 'Error: issues found'
    mock.return_value.stderr = ''
    return mock


@pytest.fixture
def mock_subprocess_error(mocker):
    """Mock subprocess.run to return error (exit code 2)."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 2
    mock.return_value.stdout = ''
    mock.return_value.stderr = 'Error: tool not found'
    return mock


@pytest.fixture
def mock_file_not_found(mocker):
    """Mock subprocess.run to raise FileNotFoundError."""
    mock = mocker.patch('subprocess.run')
    mock.side_effect = FileNotFoundError('Tool not found')
    return mock


@pytest.fixture
def mock_timeout(mocker):
    """Mock subprocess.run to raise TimeoutExpired."""
    mock = mocker.patch('subprocess.run')
    mock.side_effect = subprocess.TimeoutExpired('command', 30)
    return mock


# ===== Scenario-Specific Fixtures =====

@pytest.fixture
def secure_code():
    """Python file with no security issues"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write("""import hashlib

def hash_password(password: str) -> str:
    return hashlib.sha256(password.encode()).hexdigest()
""")
        temp_path = Path(f.name)
    yield temp_path
    if temp_path.exists():
        temp_path.unlink()


@pytest.fixture
def sql_injection_vulnerability():
    """Python file with SQL injection vulnerability"""
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write("""import sqlite3

def get_user(user_id):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = f"SELECT * FROM users WHERE id = {user_id}"  # Vulnerable
    cursor.execute(query)
    return cursor.fetchone()
""")
        temp_path = Path(f.name)
    yield temp_path
    if temp_path.exists():
        temp_path.unlink()


# ===== Subprocess Mocks for Scenarios =====

@pytest.fixture
def mock_secure_code_subprocess(mocker):
    """Mock subprocess for secure_code scenario."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 0
    mock.return_value.stdout = """No issues identified."""
    mock.return_value.stderr = """"""
    return mock


@pytest.fixture
def mock_sql_injection_vulnerability_subprocess(mocker):
    """Mock subprocess for sql_injection_vulnerability scenario."""
    mock = mocker.patch('subprocess.run')
    mock.return_value = Mock()
    mock.return_value.returncode = 1
    mock.return_value.stdout = """{"results": [{"issue_severity": "MEDIUM", "issue_text": "Possible SQL injection"}]}"""
    mock.return_value.stderr = """"""
    return mock


# ===== Mock Data Constants =====

MOCK_TOOL_VERSION = "1.0.0"

MOCK_JSON_OUTPUT_TEMPLATE = {
    "success": True,
    "issues_found": 0,
    "output": "No issues found"
}

MOCK_ERROR_OUTPUT = {
    "success": False,
    "issues_found": 0,
    "output": "Error occurred"
}
